h1. Heritage

Heritage is a gem that implements Multiple Table Inheritance for ActiveRecord models.

h2. Compatability

Heritage has only been tested with Rails 3

h2. Installation

Simply add Heritage to your Gemfile and bundle it up:

<pre>
  gem 'heritage'
</pre>

h2. Usage

Heritage works by assigning one model as your @predecessor@, and one or more other models as it's @heir@.
The predecessor is the parent of it's heirs, and thereby implicitly gives it's heirs access to it's columns, and optionally exposing methods to them.

To mark a model as predecessor, simply use the @acts_as_predecessor@ class-method:

<pre>
  class Post < ActiveRecord::Base
    acts_as_predecessor
  end
</pre>

To mark a model as heir, simply use the @acts_as_heir_of@ class-method, passing a symbol to the model that is to be the heirs predecessor.

<pre>
  class BlogPost < ActiveRecord::Base
    acts_as_heir_of :post
  end
</pre>

This takes care of the model configuration. We however need to add two extra columns to the Posts table.
We need a @heir_id@ column of type @integer@ and a @heir_type@ column of type @string@.

<pre>
  class CreatePosts < ActiveRecord::Migration
    def self.up
      create_table :posts do |t|
        t.integer :heir_id
        t.string :heir_type
        t.string :title
        t.timestamps
      end
    end

    def self.down
      drop_table :posts
    end
  end
  
  class CreateBlogPosts < ActiveRecord::Migration
    def self.up
      create_table :blog_posts do |t|
        t.text :body
      end
    end

    def self.down
      drop_table :blog_posts
    end
  end
</pre>
  
When this is done and the database is migrated, we can begin using the models.

h2. Creating new instances

Now we can simply call the following to create a new @BlogPost@

<pre>
  blog_post = BlogPost.create(:title => "Wow", :body => "That's a nice blog post!")
</pre>

Notice that the @title@ attribute belongs to the @Post@ model, and the @body@ attribute belongs to the @BlogPost@ model.

h2. Attributes

We can directly access the @title@ attribute through @BlogPost@ and even change it's value

<pre>
  blog_post.title # "Wow"
  blog_post.title = "Oh boy!"
  blog_post.save!
  blog_post.title # "Oh boy!"
</pre>

We can also update attributes like normal through @update_attributes@

<pre>
  blog_post.update_attributes(:title => "Hubba Hubba", :body => "Nice blog post!")
  blog_post.title # "Hubba Hubba"
  blog_post.body # "Nice blog post!"
</pre>

h2. Methods

If we want to expose some methods from our predecessor model to it's heirs, we can do so when calling the @acts_as_predecessor@ class-method

<pre>
  class Post < ActiveRecord::Base

    acts_as_predecessor :exposes => :hello

    def hello
      "Hi there!"
    end

  end
</pre>

Now all heirs of @Post@ will have a hello-method, which we can call directly on the heir-model:

<pre>
  blog_post = BlogPost.create(:title => "I am full", :body => "of methods...")
  blog_post.hello # "Hi there!"
</pre>

If you for some reason need to override the method in one of your heir-models, you can simply implement the method, and it will override the method from the predecessor.

<pre>
  class BlogPost < ActiveRecord::Base

    acts_as_heir_of :post

    def hello
      "Yo!"
    end

  end
</pre>

Calling the @hello@ method on BlogPost will now yield another result:

<pre>
  blog_post = BlogPost.create(:title => "I have", :body => "my own methods...")
  blog_post.hello # "Yo!"
</pre>

If we need to combine the local method in the heir, with the method in the predecessor, we can do so through the @predecessor@ method of the heir model, kinda like you would use @super@.

<pre>
  class BlogPost < ActiveRecord::Base

    acts_as_heir_of :post

    def hello
      "Yo! #{predecessor.hello}"
    end

  end
</pre>

The result would now be a combination of the local method in the heir, and the method in the predecessor:

<pre>
  blog_post = BlogPost.create(:title => "I have", :body => "my own methods...")
  blog_post.hello # "Yo! Hi there!"
</pre>

h2. Listing and filtering

To list all your wonderful heir models you do as you normally would in ActiveRecord, with one single exception.

Normally you would call something like this, to show all @BlogPosts@

<pre>
  @posts = BlogPost.all
</pre>

This however will result in 1 + the number of returned records SQL calls, which is hardly good.
Instead you need to tell ActiveRecord that it should include the predecessors of the heirs, like so:

<pre>
  @posts = BlogPost.all(:include => :predecessor)
</pre>

We now only call the database twice; Once for loading the heirs, and once for loading all referenced predecessors.

Another gotcha is when you need to filter the heirs. You can't directly filter by attributes from the predecessor model.
So in our example where we have the @title@ attribute in the @Post@ model, we can't do the following:

<pre>
  @posts = BLogPost.where("title = 'test'")
</pre>

Instead we need to reference predecessor attributes by the predecessors database-table, like so:

<pre>
  @posts = BlogPost.where("posts.title = 'test'")
</pre>

Behind the scenes, heritage works just like a simple ActiveRecord association, so it makes sense.

h2. Timestamps

If all of your heir-models needs timestamps, then you can simply add timestamps to the predecessor model, and omit them from the heir-models.
Heritage will make sure, that whenever you update your heir-model, the @updated_at@ timestamp in the predecessor model will be updated.

h2. A note on destruction

Heritage depends on the destroy-method of the models, and as such you should always delete predecessor and heir models by calling the @destroy@ method on either, and NEVER by calling the @delete@ or @delete_all@ methods.
If you absolutely need to do a direct delete in the database, then you need to manually remove the counterpart as well.

For instance, if you manually delete a @BlogPost@ that is heir of @Post@, then you need to first find the right @Post@, then delete the heir and finally delete the predecessor.

h2. Advanced usage

It is always possible to traverse between a predecessor and it's associated heir, through the @predecessor@ method of an heir, and the @heir@ method of a predecessor.

h2. Questions, Feedback

Feel free to message me on Github (murui)

h2. Contributing to Heritage

Fork, fix, then send me a pull request.

h2. Credits

Credits goes out to Gerry from TechSpry.com for the idea for this implementation:
http://techspry.com/ruby_and_rails/multiple-table-inheritance-in-rails-3/

h2. License

<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Heritage</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/BenjaminMedia/Heritage" property="cc:attributionName" rel="cc:attributionURL">Thomas Dippel</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="http://techspry.com/ruby_and_rails/multiple-table-inheritance-in-rails-3/" rel="dct:source">techspry.com</a>